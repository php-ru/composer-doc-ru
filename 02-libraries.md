# Библиотеки

В этой главе рассказывается, как сделать вашу библиотеку доступной через
Composer.

## Каждый проект — проект

Как только у вас появляется файл `composer.json` в директории, она становится
пакетом. Когда вы добавляете зависимость к проекту через команду
[`require`](04-schema.md#require), вы делаете зависимым свой пакет от других
пакетов. Единственная разинца между вашим проектом и библиотекой заключается в
том, что ваш проект представляет собой пакет без имени.

Для того, чтобы сделать этот пакет доступным к установке для других, вам нужно
дать ему имя. Вы можете сделать это, добавив свойство
[`name`](04-schema.md#name) в файл `composer.json`:

```json
{
    "name": "acme/hello-world",
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```

В данном случае имя проекта — `acme/hello-world`, где `acme` — имя разработчика.
Указание имени разработчика обязательно.

> **Примечание:** Если вы не знаете, что использовать в качестве имени
> разработчика, ваше имя пользователя на GitHub обычно является правильным
> решением. Хотя имена пакетов нечувствительны к регистру, принято соглашение,
> что все имена пишутся строчными буквами с использованием тире в качестве
> разделения слов.

## Версионирование библиотеки

В подавляющем большинстве случаев вы будете поддерживать свою библиотеку,
используя определенную систему контроля версий, например, git, svn, hg или
fossil. В таких случаях Composer подразумевает версии из вашего VCS, и поэтому
вам **не нужно** указывать версию в файле `composer.json`. (Читайте [статью
«Версии»](articles/versions.md), чтобы узнать, как Composer использует ветки и
теги VCS для разрешения ограничений версий.)

Если вы поддерживаете пакеты вручную (т.е. не используете VCS), вам нужно будет
указать версию явно, добавив поле `version` в файл `composer.json`:

```json
{
    "version": "1.0.0"
}
```

> **Примечание:** Когда вы жёстко задаёте версию в VCS, эта версия будет
> конфликтовать с именами тегов. Composer не сможет определить номер версии.


### Версионирование через VCS

Composer использует ветку и теги VCS для определения ограничений версии, которые
вы указываете в поле `require`. При определении корректных доступных версий,
Composer просматривает все ваши теги и ветки и переводит их имена во внутренний
список опций, которые затем сопоставляются с указанным вами ограничением версии.

Подробнее о том, как Composer обрабатывает теги и ветки, и то, как он разрешает
ограничения версии пакета, читайте [эту статью](articles/versions.md).

## Файл блокировки

Если хотите для вашей библиотеки вы можете зафиксировать в репозитории файл
`composer.lock`. Это может помочь вашей команде всегда использовать одни и те же
версии зависимостей. Однако этот файл блокировки не будет влиять на другие
проекты, которые зависят от него. Он влияет только на основной проект.

Если вы не хотите фиксировать в VCS файл блокировки, используя git, то добавьте
его в файл `.gitignore`.

## Публикация в VCS

После того, как у вас есть репозиторий VCS (version control system — система
контроля версиями, к примеру, git), содержащий файл `composer.json`, ваша
библиотека готова для установки через Composer. В этом примере мы опубликуем
библиотеку `acme/hello-world` на GitHub по адресу
`github.com/username/hello-world`.

Теперь, чтобы проверить установку пакета `acme/hello-world`, мы создадим новый
проект локально. Назовём его `acme/blog`. Этот блог будет зависеть от
`acme/hello-world`, который, в свою очередь, зависит от `monolog/monolog`. Для
того, чтобы всё это сделать, нужно создать где-нибудь новую директорию под
названием `blog`, содержащий файл `composer.json`:

```json
{
    "name": "acme/blog",
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

В данном случае название не требуется, поскольку мы не хотим публиковать блог
как библиотеку. Но поле `name` добавлено для пояснения, про какой именно файл
`composer.json` идёт речь.

Теперь нам нужно указать приложению блога, где можно найти зависимость
`hello-world`. Это делается путем добавления определения репозитория пакета в
файл `composer.json` блога:

Now we need to tell the blog app where to find the `hello-world` dependency. We
do this by adding a package repository specification to the blog's
`composer.json`:

```json
{
    "name": "acme/blog",
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/username/hello-world"
        }
    ],
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

Подробнее о том, как работают репозитории пакетов и какие ещё другие типы
доступны, смотрите в разделе «[Репозитории](05-repositories.md)».

Вот и всё. Теперь вы можете установить зависимости, запустив Composer-команду
[`install`](03-cli.md#install)!

**Повторим:** Любой репозиторий (git/svn/hg/fossil), в котором есть файл
`composer.json`, можно добавить в ваш проект, указав репозиторий пакета и
объявив его как зависимость в поле [`require`](04-schema.md#require).

## Публикация в Packagist

Отлично, теперь вы можете публиковать пакеты. Но указывать каждый раз
репозиторий VCS довольно обременительно. Вряд ли вы хотите принуждать всех своих
пользователей делать это.

Другое дело, что вы, скорее всего, заметили, что мы не указали репозиторий для
пакета `monolog/monolog`. Откуда в таком случае данный пакет загружается? Ответ
прост — Packagist.

[Packagist](https://packagist.org/) — основной репозиторий пакетов для Composer,
который по умолчанию включен. Всё, что опубликовано в Packagist, доступно
автоматически через Composer. Поскольку [Monolog находится в
Packagist](https://packagist.org/packages/monolog/monolog), мы может
использовать его как зависимость для проекта, не указывая никаких определений
репозиториев (т.е. откуда его можно загрузить).

Если бы мы хотели поделиться со всем миром нашим пакетом `hello-world`, мы будем
опубликуем его на Packagist, поскольку сделать это очень просто.

Вы просто заходите на [Packagist](https://packagist.org) и нажимаете кнопку
«Submit». После этого вас перенаправит на страницу входа в аккаунт, поэтому
перед публикацией вам нужно зарегистрироваться, сделать это также можно через
GitHub, после этого вы будете перенаправлены на страницу для публикации пакета,
для чего нужно только указать URL-адрес репозитория пакета, и уже сделав это,
Packagist начнет сканирование репозитория. Как только всё будет готово, ваш
пакет будет доступен для всех!

&larr; [Основы использования](01-basic-usage.md) | [Интерфейс командной
строки](03-cli.md) &rarr;

<!-- ready: yes -->
<!-- revision: d835983b15f030ef9e699f8ece470840fac92f52 -->